
\ifx\pdfoutput\undefined \documentclass[clock,landscape]{slides} \else
\documentclass[clock,landscape]{slides} \fi
%\documentclass[clock,pdftex,landscape]{slides} \fi

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Escrevendo em português:
\usepackage[brazil]{babel}
\usepackage[latin1]{inputenc} % isso é quase redundante
\usepackage{textcomp}
\usepackage[T1]{fontenc}
\usepackage{multirow}
\usepackage{graphicx}
\usepackage{epstopdf}

\usepackage{clrscode}
\usepackage{algorithm}
\usepackage{multicol}

\usepackage{psfrag}

%----------------------------
\usepackage{tabularx}

\usepackage{shi}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{amsmath,amssymb,amsthm} \usepackage{amsfonts}
\usepackage[colorlinks,backref]{hyperref}
%\usepackage{background}

%\usepackage{picinpar}

\hypersetup{pdftitle={Arquiteturas paralelas e distribuídas},
  pdfsubject={Algoritmos paralelos}, 
  pdfauthor={Leonardo Takuno, Centro Universitário SENAC, 
  <leonardo.takuno@gmail.com>},
  pdfkeywords={acrobat, ppower4},
%  pdfpagemode={FullScreen},
  colorlinks={false},
  linkcolor={red}
}

\usepackage{color}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\usepackage{pause}
\newcommand\plone{\pause\pauselevel{=1}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newtheoremstyle{mythm}% name
  {40pt}%      Space above
  {-15pt}%      Space below
  {\sf\itshape\blue}%      Body font
  {}%         Indent amount (empty = no indent, \parindent = para indent)
  {\sf\bfseries\green}% Thm head \vspacefont
  {.}%        Punctuation after thm head
  { }%     Space after thm head: " " = normal interword space;
        %       \newline = linebreak
  {}%         Thm head spec (can be left empty, meaning `normal')

\theoremstyle{mythm}
\newtheorem{theorem}             {Theorem}       
\newtheorem{claim}     [theorem] {Claim}         
\newtheorem{lemma}     [theorem] {Lemma}         
\newtheorem{corollary} [theorem] {Corollary}     
\newtheorem{fact}      [theorem] {Fact}          
\newtheorem{conjecture}[theorem] {Conjecture}    
\newtheorem{problem}   [theorem] {Problem}       

\newtheorem{propriedade}  [theorem] {Propriedade}       
\newtheorem{corolario}  [theorem] {Corolário}       
\newtheorem{teorema}  [theorem] {Teorema}       

\def\proofname{{\bf\green Prova.}}

%%% Symbole

\newcommand{\NN}{\mathbb{N}} \newcommand{\RR}{\mathbb{R}}
\newcommand{\ZZ}{\mathbb{Z}} \newcommand{\1}{{{\mathchoice {\rm
        1\mskip-4mu l} {\rm 1\mskip-4mu l} {\rm 1\mskip-4.5mu l} {\rm
        1\mskip-5mu l}}}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\let\phi\varphi
\let\epsilon\varepsilon
\let\rho\varrho
\let\tilde\widetilde
\let\approx\thickapprox
\let\sim\thicksim

\def\({\left(}
\def\){\right)}
\def\[{\left[}
\def\]{\right]}
\def\<{\langle}
\def\>{\rangle}
\let\:\colon
\def\llfloor{\left\lfloor}
\def\rrfloor{\right\rfloor}
\def\llceil{\left\lceil}
\def\rrceil{\right\rceil}

%%% Textmakros
\def\ex{\mathop{\text{\rm ex}}\nolimits} 
\def\cB{{\mathcal B}} 
\def\cG{{\mathcal G}}
\def\cS{{\mathcal S}} 
\def\cW{{\mathcal W}} 
\def\cQ{{\mathcal Q}} 
\def\PP{{\mathbb P}}
\def\EE{{\mathbb E}} 
\def\GG{{\mathbb G}} 
\def\e{{\rm e}}
\def\epsilon{{\varepsilon}} 
\def\DISC{\mathop{\textrm{\rm DISC}}\nolimits} 
\def\EIG{\mathop{\textrm{\rm EIG}}\nolimits}
\def\CIRCUIT{\mathop{\textrm{\rm CIRCUIT}}\nolimits}
\def\CYCLE{\mathop{\textrm{\rm CYCLE}}\nolimits}
\def\SUB{\mathop{\textrm{\rm SUB}}\nolimits}
\def\NSUB{\mathop{\textrm{\rm NSUB}}\nolimits}
\def\PAIR{\mathop{\textrm{\rm PAIR}}\nolimits}
\def\TFNSUB{\mathop{\textrm{\rm TFNSUB}}\nolimits}
\def\BDD{\mathop{\textrm{\rm BDD}}\nolimits}
\def\eps{\varepsilon}

\def\rmd{\text{\rm d}}
\def\wtc{\widetilde{c}\,}
\def\whc{\widehat{c}}
\def\bfb{{\bf b}}
\def\bff{{\bf f}}
\def\bft{{\bf t}}
\def\bfx{{\bf x}}
\def\bfz{{\bf z}}
\def\cB{{\mathcal B}}
\def\cD{{\mathcal D}}
\def\cG{{\mathcal G}}
\def\cM{{\mathcal M}}
\def\cN{{\mathcal N}}
\def\cR{{\mathcal R}}
\def\cS{{\mathcal S}}
\def\cW{{\mathcal W}}
\def\PP{{\mathbb P}}
\def\EE{{\mathbb E}}
\def\FF{{\mathbb F}}
\def\NN{{\mathbb N}}
\def\RR{{\mathbb R}}
\def\ZZ{{\mathbb Z}}
\def\e{{\rm e}}
\def\card{\mathop{\text{\rm card}}\nolimits}
\def\rank{\mathop{\text{\rm rank}}\nolimits}
\def\trace{\mathop{\text{\rm trace}}\nolimits}
\def\Ave{\mathop{\text{\rm Ave}}\nolimits}
\def\Bi{\mathop{\text{\rm Bi}}\nolimits}
\def\im{\mathop{\text{\rm im}}\nolimits}
\def\ind{\mathop{\text{\rm ind}}\nolimits}
\def\dist{\mathop{\text{\rm dist}}\nolimits}
\def\nDist{\mathop{\text{\rm \#Dist}}\nolimits}
\let\Dist\nDist
\def\De{D_{\rm e}}
\def\sumL{\sum\nolimits_1}
\def\sumS{\sum\nolimits_2}
\def\GF{\mathop{\text{\rm GF}}\nolimits}
\let\FF\GF
\def\Bip{\mathop{\text{\rm Bip}}\nolimits}
\def\adj{\mathop{\text{\rm adj}}\nolimits}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\nx}{{\hfill\vspace*{-2cm}\tiny +}}

%\newcommand{\red}[1]{\textcolor{red}{#1}}
%\newcommand{\blue}[1]{\textcolor{blue}{#1}}
%\newcommand{\yellow}[1]{\textcolor{yellow}{#1}}
%\newcommand{\green}[1]{\textcolor{green}{#1}}
%\newcommand{\darkgreen}[1]{\textcolor{darkgreen}{#1}}
\def\red{\color[rgb]{0.7,0,0}}
\def\green{\color[rgb]{0,.8,0}}
\def\darkgreen{\color[rgb]{0.1,0.4,0.0}}
\let\dgreen\darkgreen
\def\blue{\color[rgb]{0,0,.8}}
\def\yellow{\color[rgb]{1,1,0}}
\def\black{\color[rgb]{0,0,0}}

\def\pink{\color[rgb]{1,0,1}}
\def\brown{\color[rgb]{.5,.1,.3}}
\def\lilaz{\color[rgb]{.5,0,.5}}
\def\hmmm{\color[rgb]{.3,.1,.5}}
\def\magenta{\color[rgb]{.6,.05,.05}}

\newcommand{\uc}[1]{\centerline{\underline{#1}}}
\newcommand{\pic}[1]{\fbox{picture:{#1}}}
%\renewcommand{\bf}{\mbox{}}
\newcommand{\cP}{{\cal P}} \newcommand{\cT}{{\cal T}}
\newcommand{\add}{\mbox{\rm add}} \newcommand{\pr}{\mbox{\rm Pr}}

\def\stitle#1{\slidetitle{\red #1}\vspace{-0pt}}

\def\itemtrig{$\vartriangleright$}
\def\itemcirc{$\circ$}
\def\itemT{\item[\itemtrig]}
\def\itemC{\item[$\circ$]}

\everymath={\blue}
\everydisplay={\blue}

\renewcommand{\For}{\textbf{\blue para} }
\renewcommand{\To}{\textbf{\blue até} }
\renewcommand{\By}{\textbf{by} }
\renewcommand{\Downto}{\textbf{downto} }
\renewcommand{\While}{\textbf{\blue enquanto} }
\renewcommand{\Repeat}{\textbf{\blue repita}\>\>\addtocounter{indent}{1}}
\renewcommand{\Until}{\kill\addtocounter{indent}{-1}\liprint\>\>\textbf{until}\hspace*{-0.7em}\'}
\renewcommand{\If}{\textbf{\blue se} }
\renewcommand{\Then}{\textbf{\blue então}\>\addtocounter{indent}{1}}
\renewcommand{\Else}{\kill\addtocounter{indent}{-1}\liprint\textbf{\blue senão}\>\addtocounter{indent}{1}}
\renewcommand{\End}{\addtocounter{indent}{-1}}
\renewcommand{\ElseIf}{\kill\addtocounter{indent}{-1}\liprint\textbf{\blue senão se} }
\renewcommand{\ElseNoIf}{\kill\addtocounter{indent}{-1}\liprint\textbf{else} \addtocounter{indent}{1}}
\renewcommand{\Do}{\>\>\textbf{\blue faça}\hspace*{-0.7em}\'\addtocounter{indent}{1}}
\renewcommand{\Return}{\textbf{\blue devolva} }
\renewcommand{\Comment}{$\hspace*{-0.075em}\rhd$ }
\renewcommand{\RComment}{\`\Comment}
\renewcommand{\Goto}{\textbf{goto} }
\renewcommand{\Error}{\textbf{error} } % optionally followed by string argument
\newcommand{\DoPar}{\textbf{\blue faça em paralelo}\addtocounter{indent}{1}}
\newcommand{\DoSeq}{\textbf{\blue faça}\addtocounter{indent}{1}}
\newcommand{\Senao}{\kill\addtocounter{indent}{-1}\textbf{\blue senão}\addtocounter{indent}{1}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%\def\enddiscard{}
%\long\def\discard#1\enddiscard{}
%
%%%\vpagecolor{bgblue}
%\hypersetup{pdfpagetransition=Dissolve}
%\hypersetup{pdfpagetransition=R}
%


\definecolor{bgblue}{rgb}{0.04,0.39,0.53}

\definecolor{darkyellow}{rgb}{0.94,0.820,0.058}
\definecolor{orange}{rgb}{0.95,0.47,0.14}
\definecolor{darkgreen}{rgb}{0.0,0.5,0.0}

\definecolor{blue2}{rgb}{0.1,0.39,0.53}
\definecolor{yellow1}{rgb}{1,1,0} \definecolor{pink}{rgb}{1,0,1}

\definecolor{lightred}{rgb}{1,0.5,0.5}
\definecolor{lightred2}{rgb}{1,0.7,0.7}
\definecolor{lightred3}{rgb}{1,0.3,0.3}
\definecolor{black}{rgb}{0,0,0} \definecolor{gray1}{rgb}{0.9,0.9,0.9}
\definecolor{red1}{rgb}{1,1,0.9}

\title{Arquitetura paralela e distribuída} 
\author{{\blue L.~Takuno} (SENAC)}
\date{{\dgreen 1o. Semestre 2015}}


\begin{document}

%\maketitle

%\slidesubhead{}

%\slidesubhead{Outline!!!}

\begin{slide}
  \stitle{Fontes principais}
  \begin{enumerate}\makeatletter\itemsep\z@\makeatother
  \item Lima, A. C., Soluções para os problemas de soma máxima e do k-ésimo menor elemento de uma sequência usando modelo BSP/CGM, tese de doutorado em ciência da computação, Universidade Federal de Mato Grosso do Sul, 2015, Campo Grande - MS.
  \end{enumerate}
\end{slide}


\begin{slide}
  \stitle{Subsequência de soma máxima}
\end{slide}

\begin{slide}
  \stitle{Subsequência de soma máxima}

Problema: Dada uma sequência $x$ de números reais, encontrar uma subsequência contígua com a maior soma de seus elementos.
\end{slide}

\begin{slide}
  \stitle{Subsequência de soma máxima (em outras palavras)}

Dada uma sequência de $n$ números reais $x = (x_1, x_2, \cdots, x_n)$. Uma subsequência contígua é qualquer intervalo $(x_i, \cdots, x_j)$ de $x$, tal que $0 \leq i \leq j \leq n$.


Por simplicidade consideraremos subsequência como subsequência contígua.

\textbf{Objetivo:} Determinar a subsequência $(x_i, \cdots, x_j)$ que possua o maior somatório $T = \sum^j_{k = i} x_k$
\end{slide}

\begin{slide}
  \stitle{Subsequência de soma máxima (modelo PRAM) \\  \vspace{0.5cm} {\blue \small Algoritmo de Perumalla e Deo}}
 
\end{slide}

\begin{slide}
  \stitle{Subsequência de soma máxima (modelo PRAM)}
  
  Dada uma sequência $Q =[q_1, q_2, \cdots, q_n]$, considere $Q_{ij}$ como sendo a subsequência $[q_i, q_{i+1}, \cdots, q_j]$, defina:
  
  \itemtrig\ $Range(q_k)$: o conjunto de todas as subsequências de soma máxima de $Q$ que incluem $q_k$. 
  
  Se todos os valores de $q_i$ são negativos, então a subsequência de soma máxima de $Q$ é definida como o menor número negativo encontrado. Pode-se redefinir este valor para zero, caso desejado.
\end{slide}

\begin{slide}
  \stitle{Subsequência de soma máxima (modelo PRAM)}
  
Considere um elemento $q_k \in Q$, defina:

\itemtrig\ $l(q_k) = [q_1, q_2, \cdots, q_{k-1}, q_k]$ a subsequência composta pelos elementos a esquerda de $q_k$ incluindo $q_k$.

\vspace{-1cm}\itemtrig\ $r(q_k) = [q_k, q_{k+1}, \cdots, q_n]$ a subsequência composta pelos elementos a direita de $q_k$ incluindo $q_k$
\end{slide}

\begin{slide}
  \stitle{Subsequência de soma máxima (modelo PRAM)}

Sejam  
  
\itemtrig\ $S_l(q_k) = [s_1, s_2, \cdots, s_k]$ a soma de sufixos de $l(q_k)$

\vspace{-1cm}\itemtrig\ $P_r(q_k) = [p_k, p_{k+1}, \cdots, p_n]$ a soma de prefixos de $r(q_k)$

\vspace{-1cm}\itemtrig\ $M_s^k$ o valor máximo da soma de sufixos de $S_l(q_k)$

\vspace{-1cm}\itemtrig\ $M_p^k$ o valor máximo da soma de prefixos de $P_r(q_k)$
\end{slide}

\begin{slide}
  \stitle{Subsequência de soma máxima (modelo PRAM)}
  \begin{lemma}
  O valor máximo entre as somas de todas as subsequências que incluem $q_k$ é dado por $Max(q_k) = M_s^k + M_p^k - q_k$.
  \end{lemma}

Demonstração: Considere $SQ_{ij}$ com a soma dos elementos $Q_{ij}$. 

\vspace{-1cm}\itemcirc\ Agora considere a subsequência definida por $Q_{ab}^k$, desta forma $M_s^k = SQ_{ak}$ e $M_p^k = SQ_{kb}$, para $1 \leq a \leq k \leq b \leq n$.

\vspace{-1cm}\itemcirc\ Considere agora que existe uma outra subsequência $Q_{a'b'}^k$ que inclui $q_k$, tal que a soma $SQ_{a'b'}^k$ é maior que a soma dada por $SQ_{ab}^k$.
\end{slide}

\begin{slide}
  \stitle{Subsequência de soma máxima (modelo PRAM)}

A subsequência $Q_{a'b'}^k$ pode ser vista como duas subsequências $Q_{a'k}$ e $Q_{kb'}$, ambas incluíndo $q_k$, o valor da soma $SQ_{a'b'}^k$ pode ser escrito como $SQ_{a'b'}^k = Q_{a'k} + Q_{kb'} - q_k$.

\begin{center}
\includegraphics[width=20.3cm]{fig01}
\end{center} 
\end{slide}

\begin{slide}
  \stitle{Subsequência de soma máxima (modelo PRAM)}
  
  Entretanto, por definição $M_s^k = SQ_{ak} \geq SQ_{ik}$ para todo $1 \leq i \leq k$, segue assim que $SQ_{ab'} \geq SQ_{a'b'}$. 
  
  Um argumento similar pode ser aplicado para $b$ e $b'$, dado que $SQ_{ab} \geq SQ_{a'b'}$, então $SQ_{ab}^k \geq SQ_{a'b'}^k$ para todo $SQ_{a'b'}^k \in Range(q_k)$. $\Box$
\end{slide}

\begin{slide}
  \stitle{Subsequência de soma máxima (Exemplo)}
\begin{center}
\includegraphics[width=20.3cm]{fig02}
\end{center} 
\end{slide}

\begin{slide}
  \stitle{Subsequência de soma máxima (Exemplo)}
Para $M_{s}^7$ temos os seguintes valores:

\itemcirc\ $M_{s}^7 =$ Máximo$(S_l) = 19$

\vspace{-1cm}\itemcirc\ $M_{p}^7 =$ Máximo$(P_r) = 13$

\itemcirc\ $M_{s}^7 + M_{p}^7 - q_7 = 19 + 13 - 4 = 28 = Max(q_7)$
\end{slide}

\begin{slide}
  \stitle{Subsequência de soma máxima (Exemplo)}

Suponha que o valor $Max(q_k)$ é calculado para todo valor $q_k$ da sequência $Q$, a soma máxima entre todas as subsequências que incluem $q_k$ é computada.

Então claramente, a subsequência de soma máxima de $Q$ é composta pelos máximos destes máximos, isto é:

\hspace{2cm}$MaxSeqSum = $Máximo$(Max(q_k), 1 \leq k \leq n)$.
\end{slide}

\begin{slide}
  \stitle{Subsequência de soma máxima (Algoritmo PRAM)}

\itemtrig\ Entrada: Sequência $Q[1 \cdots n]$ de números inteiros.

\vspace{-1cm}\itemtrig\ Saída: Subsequência de soma máxima $Q$.
  
\end{slide}


\begin{slide}
  \stitle{Subsequência de soma máxima (Algoritmo PRAM)}


\begin{codebox}
  \li Compute em paralelo as somas de prefixos de $Q$ no vetor $PSUM$.
  \li Compute em paralelo as somas de sufixos de $Q$ no vetor $SSUM$.
  \li Compute em paralelo o sufixo máx. de $PSUM$ no vetor $SMAX$.
  \li Compute em paralelo o prefixo máx. de $SSUM$ no vetor $PMAX$.
  \li \For $i = 1$ \To $n$ \DoPar 
  \zi     (a) $M_s[i] := PMAX - SSUM[i] + Q[i]$
  \zi     (b) $M_p[i] := SMAX - PSUM[i] + Q[i]$
  \zi     (c) $M[i] := M_s[i] + M_p[i] - Q[i]$
  \End   
  \li Localize a sequência contígua de máximos de $M$ e armazene \\
   os valores
   correspondentes de $Q$ em $MSQ$
   \li Imprima a subsequência de soma máxima $MSQ$.
\end{codebox} 
\end{slide}


\begin{slide}
  \stitle{Subsequência de soma máxima (Algoritmo PRAM)}
Entrada: $Q = \{3,2,-7,11,10,-6,4,9,-6,1,-2,-3,4,-3,0,2\}$

\begin{center}
\includegraphics[width=24.5cm]{fig03}
\end{center} 
  
\itemtrig\ Soma máxima de uma subsequência: 28

\vspace{-1cm}\itemtrig\ Subsequência de soma máxima: elementos do intervalo $[4,8]$
\end{slide}


\begin{slide}
  \stitle{Subsequência de soma máxima (Algoritmo PRAM)}
Custo do algoritmo

\hspace{1cm}\itemcirc\ passos 1 e 2: $O(\lg n)$ usando algoritmos de soma de prefixos e soma de sufixos.

\hspace{1cm}\itemcirc\ passos 3 e 4: podem ser resolvidos por $O(n/\lg n)$ processadores em uma máquina EREW em tempo $O(\lg n)$ utilizando variações de algoritmos de soma de prefixos e soma de sufixos.

\hspace{1cm}\itemcirc\ passo 5: $O(1)$

\hspace{1cm}\itemcirc\ passo 6: $O(\lg n)$

Tempo total: $O(\lg n)$
\end{slide}

\begin{slide}
  \stitle{Subsequência de soma máxima (BSP/CGM)}
\end{slide}

\begin{slide}
  \stitle{Subsequência de soma máxima (BSP/CGM)}
  Utilizando as ideias de Perumalla e Deo é possível desenvolver um algoritmo paralelo BSP/CGM para o problema.
\end{slide}

\begin{slide}
  \stitle{Subsequência de soma máxima (BSP/CGM)}

Entrada:

\hspace{2cm}1. Um conjunto de $P$ processadores;

\vspace{-1cm}\hspace{2cm}2. O número $i$ que rotula cada processador $p_i \in P$, 

\vspace{-1cm}\hspace{3cm}onde $1 \leq i \leq P$;

\vspace{-1cm}\hspace{2cm}3. Uma sequência $Q$ de inteiros.

Saída:

\vspace{-1cm}\hspace{2cm}1. O vetor $M[1 \cdots n]$ de inteiros com todas as 

\vspace{-1cm}\hspace{3cm}subsequências disjuntas de soma máxima.

\vspace{-1cm}\hspace{2cm}2. O valor da soma máxima de $M$.
  
\end{slide}

\begin{slide}
\begin{codebox}
  \li Utilize o conjunto de processadores $P$ e o vetor $Q$ 
  \zi para obter as somas de prefixos de $Q$ no vetor $PSUM$.
  \li Utilize o conjunto de processadores $P$ e o vetor $Q$ 
  \zi para obter as somas de sufixos de $Q$ no vetor $SSUM$.
  \li $SMAX := \proc{sufixos\_maximos}(PSUM)$.
  \li $PMAX := \proc{prefixos\_maximos}(SSUM)$.
  \li Processador $p_1$ envia $n/p$ elementos de cada vetor $Q$,
  \zi $PSUM$, $SSUM$, $SMAX$, $PMAX$ para cada processador $p_i \in P$.
  \li Cada processador $p_i$ obtém os vetores locais
  \zi $LocalM_s := PMAX(n/p) - SSUM(n/p) + Q(n/p)$
  \zi $LocalM_p := SMAX(n/p) - PSUM(n/p) + Q(n/p)$
  \zi $LocalM := LocalM_s(n/p) + LocalM_s(n/p) - Q(n/p)$
  \li Cada processador $p_i$ envia o vetor $LocalM$ para o processador $p_1$, 
  \zi que computa o array: 
  \zi $M = [LocalM_{p_1, 1} \cdots LocalM_{p_1, n/p} \cdots LocalM_{p_p, 1} \cdots LocalM_{p_p, n/p}]$
   \li Encontre o maior valor númerico em $M$ (soma máxima)
\end{codebox} 
\end{slide}

\begin{slide}
  \stitle{Algoritmo de sufixos máximos (BSP/CGM)}

\vspace{-1cm}Entrada: Vetor $PSUM[1 \cdots n]$ de inteiros;

\vspace{-1cm}Saída: Vetor $SMAX[1 \cdots n]$ de inteiros;
\end{slide}

\begin{slide}
Algoritmo $\proc{sufixos\_maximos}$  
  
\begin{codebox}
\li Processador $p_1$ envia $n/p$ elementos de $PSUM$ para cada 
\zi processador $p_i \in P$.
\li Em cada processador $p_i$, uma operação de propagação de 
\zi máximos deve ser executada em cada vetor $PSUM(n/p)$. 
\zi A operação é iniciada no elemento de índice $n/p$ e 
\zi executa até o elemento de índice 1. Ao final o maior 
\zi elemento está na primeira posição.
\li Por fim, uma operação de propagação de máximos também 
\zi é executada entre os processadores, sendo que cada 
\zi processador $p_i$ irá trabalhar com os 
\zi processadores $p_k$ onde $k > i$.
\end{codebox} 
\end{slide}

 
\begin{slide}
  \stitle{Algoritmo de prefixos máximos (BSP/CGM)}

\vspace{-1cm}Entrada: Vetor $SSUM[1 \cdots n]$ de inteiros;

\vspace{-1cm}Saída: Vetor $PMAX[1 \cdots n]$ de inteiros;
\end{slide}

\begin{slide}
Algoritmo $\proc{prefixos\_maximos}$  
  
\begin{codebox}
\li Processador $p_1$ envia $n/p$ elementos de $SSUM$ para cada 
\zi processador $p_i \in P$.
\li Em cada processador $p_i$, uma operação de propagação de 
\zi máximos deve ser executada em cada vetor $SSUM(n/p)$. 
\zi A operação é iniciada no elemento de índice 1 e 
\zi executa até o elemento de índice $n/p$. Ao final o maior 
\zi elemento está na posição $n/p$.
\li Por fim, uma operação de propagação de máximos também 
\zi é executada entre os processadores, sendo que cada 
\zi processador $p_i$ irá trabalhar com os 
\zi processadores $p_k$ onde $k < i$.
\end{codebox} 
\end{slide}

 
\begin{slide}
  \stitle{Algoritmo de prefixos máximos (BSP/CGM)}
  Nestes algoritmos duas operações são executadas, entretanto ambas consistem basicamente de propagação de valores máximos.
  
  \itemcirc\ A primeira ocorre nos vetores locais, em que os valores maiores substituem os valores menores.
  
  \itemcirc\ A segunda ocorre entre os processadores, o valor máximo de cada processador é enviado para o processador subsequente ou precedente.
\end{slide}

\begin{slide}
  \stitle{Subsequência de soma máxima (BSP/CGM)}
  Propagação de valores máximos locais
  
\begin{center}
\includegraphics[width=16.3cm]{fig04}
\end{center} 
  
\end{slide}


\begin{slide}
  \stitle{Subsequência de soma máxima (BSP/CGM)}
  Propagação de valores máximos entre processadores
  
\begin{center}
\includegraphics[width=21.3cm]{fig05}
\end{center} 
\end{slide}

\begin{slide}
\stitle{Subsequência de soma máxima (BSP/CGM)}
  Complexidade do algoritmo de subsquência de soma máxima:

\hspace{1cm}\itemcirc\ passos 1 e 2: pode ser computado utilizando $p$ processadores em tempo $O(n/p)$ e com número constante de rodadas de comunicação.


\hspace{1cm}\itemcirc\ passos 3 e 4: a invocação dos algoritmos $\proc{sufixos\_maximos}$ e $\proc{prefixos\_maximos}$, utiliza, respectivamente, $p$ processadores e consome tempo $O(n/p)$ com número constante de rodada de comunicação.

\hspace{1cm}\itemcirc\ passos 5 a 7: podem ser computados utilizando $p$ processadores em tempo $O(n/p)$ com número constante de rodada de comunicação.


\hspace{1cm}\itemcirc\ passo 8: algoritmo de redução para o máximo utiliza $p$ processadores em tempo $O(n/p)$ com número constante de rodada de comunicação.

Tempo total: $O(n/p)$, com $p$ processadores e número constante de rodadas de comunicação.
\end{slide}

\begin{slide}
\stitle{Subsequência de soma máxima - MPI}
\end{slide}

\begin{slide}
\stitle{Subsequência de soma máxima - MPI}
\begin{verbatim}
#include<mpi.h>
#include<stdio.h>
#include<stdlib.h>
#include<limits.h>

#define MASTER 0
#define n 16

#define max(a, b) ((a) > (b)) ? (a) : (b)
#define min(a, b) ((a) < (b)) ? (a) : (b)
int main(int argc, char *argv[]) {

   int id, p;
   MPI_Init(&argc,&argv);
   MPI_Comm_size(MPI_COMM_WORLD,&p);
   MPI_Comm_rank(MPI_COMM_WORLD,&id);


   // id de processos
   int *pids = (int*) malloc(p*sizeof(int));

   // guarda os ids de processo na ordem reversa 
   for(int i = 0; i < p; i++){
      pids[i] = p - i - 1;
   }

   MPI_Group group_world;
   MPI_Group reverse_group;
   MPI_Comm reverse_comm;

   MPI_Comm_group(MPI_COMM_WORLD, &group_world);
   MPI_Group_incl(group_world, p, pids, &reverse_group);
   MPI_Comm_create(MPI_COMM_WORLD, reverse_group, &reverse_comm);

   int input[n] = {3, 2, -7, 11, 10, -6, 4, 9, -6, 
                   1, -2, -3, 4, -3, 0, 2};
   int q[n];
   int psum[n] = {0};
   int ssum[n] = {0};
   int pmax[n] = {0};
   int smax[n] = {0};
   
   int r = (n/p);

   // Distritua a entrada
   MPI_Scatter(input, r, MPI_INT, q, r, MPI_INT, MASTER, 
                                          MPI_COMM_WORLD);
   MPI_Barrier(MPI_COMM_WORLD);

   // calcular a soma de prefixos de Q no array PSUM
   psum[0] = q[0];
   for (int i = 1; i < r; i++){
      psum[i] = q[i] + psum[i-1];
   }




   // calcular a soma de sufixo de Q no array SSUM
   ssum[r - 1] = q[r - 1];
   for (int i = r - 2; i >= 0; i--){
     ssum[i] = q[i] + ssum[i + 1];
   }
   
   int psum_reduce = psum[r - 1];
   int ssum_reduce = ssum[0];
   int psum_recv = 0, ssum_recv = 0;
   
   
   MPI_Exscan(&psum_reduce, &psum_recv, 1, MPI_INT, MPI_SUM, 
                                              MPI_COMM_WORLD);
   MPI_Exscan(&ssum_reduce, &ssum_recv, 1, MPI_INT, MPI_SUM, 
                                                reverse_comm);
   if (id > MASTER){
      for (int i = 0; i < r; i++) {
         psum[i] += psum_recv;
      }
   }


   if (id < p - 1){
      for (int i = r - 1; i >= 0; i--){
         ssum[i] += ssum_recv;
      }
   }



   // Compute em paralelo o sufixo máximo de PSUM no vetor SMAX
   smax[r - 1] = psum[r - 1];
   for (int i = r - 2; i >= 0; i--){
      smax[i]  = max(psum[i], smax[i + 1]);
   }

   // Compute em paralelo o prefixo máximo de SSUM no vetor PMAX
   pmax[0] = ssum[0];
   for (int i = 1; i < r; i++){
      pmax[i] = max(ssum[i], pmax[i - 1]);
   }
   int pmax_reduce = pmax[r - 1];
   int smax_reduce = smax[0];
   int pmax_recv, smax_recv;
   
   MPI_Exscan(&pmax_reduce, &pmax_recv, 1, MPI_INT, MPI_MAX, 
                                                 MPI_COMM_WORLD);
   MPI_Exscan(&smax_reduce, &smax_recv, 1, MPI_INT, MPI_MAX, 
                                                 reverse_comm);                                                 
   if (id > MASTER) {
      for (int i = 0; i < r; i++) {
         pmax[i] = max(pmax_recv, pmax[i]);
      }
   }

   if (id < p - 1) {
      for (int i = r - 1; i >= 0; i--) {
         smax[i] = max(smax_recv, smax[i]);
      }
   }

   int m[n] = {0};
   int ms[n] = {0};
   int mp[n] = {0};
   int maior_soma = INT_MIN;
   
   for (int i = 0; i < r; i++){
      ms[i] = pmax[i] - ssum[i] + q[i];
      mp[i] = smax[i] - psum[i] + q[i];
      m[i] = ms[i] + mp[i] - q[i];
      maior_soma = max(maior_soma, m[i]);
      printf("m[%d] = %d \n", id * r + i, m[i]);
   }
   
   
   int maior_global;
   MPI_Allreduce(&maior_soma, &maior_global, 1, MPI_INT, MPI_MAX, 
                                                    MPI_COMM_WORLD);
   printf("maior global: %d\n", maior_global);
   MPI_Finalize();
   return 0;
}  
\end{verbatim}
\end{slide}

\begin{slide}
  \stitle{Fim}
\end{slide}
\end{document}