%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% talk: prototype
%%% 2002/10/16
%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%
%%% Erstellen eines Vortrags in PDF-Format wie folgt:
%%%
%%% 1) Uebersetzen der Datei mit 
%%%    pdflatex asz
%%% 2) Wenn Features von ppower4 gewuenscht werden, dann die eben
%%%    entstandene Datei asz.pdf weiterverarbeiten mit
%%%    ./ppower4 asz.pdf vortrag.pdf
%%% 3) Die Datei vortrag.pdf kann nun mit dem Acrobat Reader angesehen
%%%    werden
%%%
%%% Fuer Testzwecke ist auch ein "normales" Uebersetzen mit LaTeX
%%% moeglich:
%%% 1) latex asz
%%% 2) dvips asz.dvi -o asz.ps -t a4 -t landscape
%%% 3) Anschauen mit ghostview
%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\ifx\pdfoutput\undefined \documentclass[clock,landscape]{slides} \else
\documentclass[clock,landscape]{slides} \fi
%\documentclass[clock,pdftex,landscape]{slides} \fi
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Escrevendo em português:
\usepackage[brazil]{babel}
\usepackage[latin1]{inputenc} % isso é quase redundante
\usepackage{textcomp}
\usepackage[T1]{fontenc}
\usepackage{multirow}
\usepackage{graphicx}
\usepackage{epstopdf}

\usepackage{clrscode}
\usepackage{algorithm}
\usepackage{multicol}

\usepackage{psfrag}

%----------------------------
\usepackage{tabularx}
%%% Die Datei mit dem ASZ-Layout

\usepackage{shi}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{amsmath,amssymb,amsthm} \usepackage{amsfonts}
\usepackage[colorlinks,backref]{hyperref}
%\usepackage{background}

%\usepackage{picinpar}

\hypersetup{pdftitle={Arquiteturas paralelas e distribuídas},
  pdfsubject={Algoritmos paralelos}, 
  pdfauthor={Leonardo Takuno, Centro Universitário SENAC, 
  <leonardo.takuno@gmail.com>},
  pdfkeywords={acrobat, ppower4},
%  pdfpagemode={FullScreen},
  colorlinks={false},
  linkcolor={red}
}

\usepackage{color}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%% Pauseneffekte mit ppower4 werden moeglich

\usepackage{pause}
\newcommand\plone{\pause\pauselevel{=1}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newtheoremstyle{mythm}% name
  {40pt}%      Space above
  {-15pt}%      Space below
  {\sf\itshape\blue}%      Body font
  {}%         Indent amount (empty = no indent, \parindent = para indent)
  {\sf\bfseries\green}% Thm head \vspacefont
  {.}%        Punctuation after thm head
  { }%     Space after thm head: " " = normal interword space;
        %       \newline = linebreak
  {}%         Thm head spec (can be left empty, meaning `normal')

\theoremstyle{mythm}
\newtheorem{theorem}             {Theorem}       
\newtheorem{claim}     [theorem] {Claim}         
\newtheorem{lemma}     [theorem] {Lemma}         
\newtheorem{corollary} [theorem] {Corollary}     
\newtheorem{fact}      [theorem] {Fact}          
\newtheorem{conjecture}[theorem] {Conjecture}    
\newtheorem{problem}   [theorem] {Problem}       

\newtheorem{propriedade}  [theorem] {Propriedade}       
\newtheorem{corolario}  [theorem] {Corolário}       
\newtheorem{teorema}  [theorem] {Teorema}       

%%% Symbole

\newcommand{\NN}{\mathbb{N}} \newcommand{\RR}{\mathbb{R}}
\newcommand{\ZZ}{\mathbb{Z}} \newcommand{\1}{{{\mathchoice {\rm
        1\mskip-4mu l} {\rm 1\mskip-4mu l} {\rm 1\mskip-4.5mu l} {\rm
        1\mskip-5mu l}}}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\let\phi\varphi
\let\epsilon\varepsilon
\let\rho\varrho
\let\tilde\widetilde
\let\approx\thickapprox
\let\sim\thicksim

\def\({\left(}
\def\){\right)}
\def\[{\left[}
\def\]{\right]}
\def\<{\langle}
\def\>{\rangle}
\let\:\colon
\def\llfloor{\left\lfloor}
\def\rrfloor{\right\rfloor}
\def\llceil{\left\lceil}
\def\rrceil{\right\rceil}

%%% Textmakros
\def\ex{\mathop{\text{\rm ex}}\nolimits} 
\def\cB{{\mathcal B}} 
\def\cG{{\mathcal G}}
\def\cS{{\mathcal S}} 
\def\cW{{\mathcal W}} 
\def\cQ{{\mathcal Q}} 
\def\PP{{\mathbb P}}
\def\EE{{\mathbb E}} 
\def\GG{{\mathbb G}} 
\def\e{{\rm e}}
\def\epsilon{{\varepsilon}} 
\def\DISC{\mathop{\textrm{\rm DISC}}\nolimits} 
\def\EIG{\mathop{\textrm{\rm EIG}}\nolimits}
\def\CIRCUIT{\mathop{\textrm{\rm CIRCUIT}}\nolimits}
\def\CYCLE{\mathop{\textrm{\rm CYCLE}}\nolimits}
\def\SUB{\mathop{\textrm{\rm SUB}}\nolimits}
\def\NSUB{\mathop{\textrm{\rm NSUB}}\nolimits}
\def\PAIR{\mathop{\textrm{\rm PAIR}}\nolimits}
\def\TFNSUB{\mathop{\textrm{\rm TFNSUB}}\nolimits}
\def\BDD{\mathop{\textrm{\rm BDD}}\nolimits}
\def\eps{\varepsilon}

\def\rmd{\text{\rm d}}
\def\wtc{\widetilde{c}\,}
\def\whc{\widehat{c}}
\def\bfb{{\bf b}}
\def\bff{{\bf f}}
\def\bft{{\bf t}}
\def\bfx{{\bf x}}
\def\bfz{{\bf z}}
\def\cB{{\mathcal B}}
\def\cD{{\mathcal D}}
\def\cG{{\mathcal G}}
\def\cM{{\mathcal M}}
\def\cN{{\mathcal N}}
\def\cR{{\mathcal R}}
\def\cS{{\mathcal S}}
\def\cW{{\mathcal W}}
\def\PP{{\mathbb P}}
\def\EE{{\mathbb E}}
\def\FF{{\mathbb F}}
\def\NN{{\mathbb N}}
\def\RR{{\mathbb R}}
\def\ZZ{{\mathbb Z}}
\def\e{{\rm e}}
\def\card{\mathop{\text{\rm card}}\nolimits}
\def\rank{\mathop{\text{\rm rank}}\nolimits}
\def\trace{\mathop{\text{\rm trace}}\nolimits}
\def\Ave{\mathop{\text{\rm Ave}}\nolimits}
\def\Bi{\mathop{\text{\rm Bi}}\nolimits}
\def\im{\mathop{\text{\rm im}}\nolimits}
\def\ind{\mathop{\text{\rm ind}}\nolimits}
\def\dist{\mathop{\text{\rm dist}}\nolimits}
\def\nDist{\mathop{\text{\rm \#Dist}}\nolimits}
\let\Dist\nDist
\def\De{D_{\rm e}}
\def\sumL{\sum\nolimits_1}
\def\sumS{\sum\nolimits_2}
\def\GF{\mathop{\text{\rm GF}}\nolimits}
\let\FF\GF
\def\Bip{\mathop{\text{\rm Bip}}\nolimits}
\def\adj{\mathop{\text{\rm adj}}\nolimits}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\nx}{{\hfill\vspace*{-2cm}\tiny +}}

%\newcommand{\red}[1]{\textcolor{red}{#1}}
%\newcommand{\blue}[1]{\textcolor{blue}{#1}}
%\newcommand{\yellow}[1]{\textcolor{yellow}{#1}}
%\newcommand{\green}[1]{\textcolor{green}{#1}}
%\newcommand{\darkgreen}[1]{\textcolor{darkgreen}{#1}}
\def\red{\color[rgb]{0.7,0,0}}
\def\green{\color[rgb]{0,.8,0}}
\def\darkgreen{\color[rgb]{0.1,0.4,0.0}}
\let\dgreen\darkgreen
\def\blue{\color[rgb]{0,0,.8}}
\def\yellow{\color[rgb]{1,1,0}}
\def\black{\color[rgb]{0,0,0}}

\def\pink{\color[rgb]{1,0,1}}
\def\brown{\color[rgb]{.5,.1,.3}}
\def\lilaz{\color[rgb]{.5,0,.5}}
\def\hmmm{\color[rgb]{.3,.1,.5}}
\def\magenta{\color[rgb]{.6,.05,.05}}

\newcommand{\uc}[1]{\centerline{\underline{#1}}}
\newcommand{\pic}[1]{\fbox{picture:{#1}}}
%\renewcommand{\bf}{\mbox{}}
\newcommand{\cP}{{\cal P}} \newcommand{\cT}{{\cal T}}
\newcommand{\add}{\mbox{\rm add}} \newcommand{\pr}{\mbox{\rm Pr}}

\def\stitle#1{\slidetitle{\red #1}\vspace{-0pt}}

\def\itemtrig{$\vartriangleright$}
\def\itemcirc{$\circ$}
\def\itemT{\item[\itemtrig]}
\def\itemC{\item[$\circ$]}

\everymath={\blue}
\everydisplay={\blue}

\renewcommand{\For}{\textbf{\blue para} }
\renewcommand{\To}{\textbf{\blue até} }
\renewcommand{\By}{\textbf{by} }
\renewcommand{\Downto}{\textbf{downto} }
\renewcommand{\While}{\textbf{\blue enquanto} }
\renewcommand{\Repeat}{\textbf{\blue repita}\>\>\addtocounter{indent}{1}}
\renewcommand{\Until}{\kill\addtocounter{indent}{-1}\liprint\>\>\textbf{until}\hspace*{-0.7em}\'}
\renewcommand{\If}{\textbf{\blue se} }
\renewcommand{\Then}{\textbf{\blue então}\>\addtocounter{indent}{1}}
\renewcommand{\Else}{\kill\addtocounter{indent}{-1}\liprint\textbf{\blue senão}\>\addtocounter{indent}{1}}
\renewcommand{\End}{\addtocounter{indent}{-1}}
\renewcommand{\ElseIf}{\kill\addtocounter{indent}{-1}\liprint\textbf{\blue senão se} }
\renewcommand{\ElseNoIf}{\kill\addtocounter{indent}{-1}\liprint\textbf{else} \addtocounter{indent}{1}}
\renewcommand{\Do}{\>\>\textbf{\blue faça}\hspace*{-0.7em}\'\addtocounter{indent}{1}}
\renewcommand{\Return}{\textbf{\blue devolva} }
\renewcommand{\Comment}{$\hspace*{-0.075em}\rhd$ }
\renewcommand{\RComment}{\`\Comment}
\renewcommand{\Goto}{\textbf{goto} }
\renewcommand{\Error}{\textbf{error} } % optionally followed by string argument
\newcommand{\DoPar}{\textbf{\blue faça em paralelo}\addtocounter{indent}{1}}
\newcommand{\DoSeq}{\textbf{\blue faça}\addtocounter{indent}{1}}
\newcommand{\Senao}{\kill\addtocounter{indent}{-1}\textbf{\blue senão}\addtocounter{indent}{1}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%%Anuschs Extras
%
%\def\enddiscard{}
%\long\def\discard#1\enddiscard{}
%
%%%\vpagecolor{bgblue}
%\hypersetup{pdfpagetransition=Dissolve}
%\hypersetup{pdfpagetransition=R}
%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%% Farben kann man hier definieren

\definecolor{bgblue}{rgb}{0.04,0.39,0.53}

\definecolor{darkyellow}{rgb}{0.94,0.820,0.058}
\definecolor{orange}{rgb}{0.95,0.47,0.14}
\definecolor{darkgreen}{rgb}{0.0,0.5,0.0}

\definecolor{blue2}{rgb}{0.1,0.39,0.53}
\definecolor{yellow1}{rgb}{1,1,0} \definecolor{pink}{rgb}{1,0,1}

\definecolor{lightred}{rgb}{1,0.5,0.5}
\definecolor{lightred2}{rgb}{1,0.7,0.7}
\definecolor{lightred3}{rgb}{1,0.3,0.3}
\definecolor{black}{rgb}{0,0,0} \definecolor{gray1}{rgb}{0.9,0.9,0.9}
\definecolor{red1}{rgb}{1,1,0.9}

\title{Arquitetura paralela e distribuída} 
\author{{\blue L.~Takuno} (SENAC)}
\date{{\dgreen 1o. Semestre 2015}}

%%% Hier beginnt die Praesentation

\begin{document}\def\proofname{{\bf\green Prova.}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Deckblatt
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\maketitle

%\slidesubhead{}  %% Teilvortrags-Titel (hier noch nicht)
                 %% Dieser erscheint spaeter oben links unter
                 %% dem ASZ Gesamt-Titel

%%%%%%%%%%%%%%%%%%%%%%% TOC %%%%%%%%%%%%%%%%%%

%\slidesubhead{Outline!!!}

\begin{slide}
  \stitle{Fontes principais}
  \begin{enumerate}\makeatletter\itemsep\z@\makeatother
  \item J. Jaja, An introduction to Parallel Algorithms, Addison Wesley, 92
    \begin{itemize}
    \itemT Algoritmos paralelos
    \end{itemize}
  \item E. Cáceres, H. Mongeli, S. Song: Algoritmos paralelos u\-san\-do CGM/PVM/MPI: uma introdução\\
    \verb|http://www.ime.usp.br/~song/papers/jai01.pdf| 
  \end{enumerate}
\end{slide}
 
   
\begin{slide}
  \stitle{Divisão e Conquista}
 \end{slide}
  
\begin{slide}
  \stitle{Divisão e Conquista}
  A estratégia de divisão e conquista consiste de três passos:
  
    \vspace{-1cm}   \hspace{1cm}   1) Particionamento da entrada em partes iguais
    
    \vspace{-1cm}   \hspace{1cm}   2) Resolver recursivamente o subproblema definido para cada partição da entrada
    
    \vspace{-1cm}   \hspace{1cm}   3) Combinar  as soluções de diferentes subproblemas numa solução para o problema global
    
    O sucesso desta estratégia depende de como o terceiro passo possa ser efetuado com eficiência.
    
 \end{slide}
\begin{slide}
  \stitle{Ordenação: Algoritmo Mergesort paralelo}
\end{slide}
 
\begin{slide}
  \stitle{Ordenação: Algoritmo Mergesort paralelo}

 Idéia:
 
\itemtrig\ Para ordenar uma sequência de n números, dividimos essa sequência em 2 metades, ordenamos cada uma das metades e fazemos o merge das 2 metades já ordenadas.

\itemtrig\ Para ordenar cada uma das metades, aplica-se a mesma idéia: divide, ordena, merge, recursivamente, até termos sequencias de tamanho 1. 
 \end{slide}
 
  
\begin{slide}
  \stitle{Ordenação: Algoritmo Mergesort paralelo}

Entrada:  

  \vspace{-1cm}   \hspace{1cm}   \itemtrig\ $A, B$: vetores de $\displaystyle \frac{n}{2}$ elementos ordenados

Saída:

  \vspace{-1cm}   \hspace{1cm}   \itemtrig\ $C$: vetor de n elementos (de $A$ e $B$) ordenado
  
  Suposição inicial: Todos os elementos de $A$ e $B$ são distintos
 \end{slide}
 
  
\begin{slide}
  \stitle{Ordenação: Algoritmo Mergesort paralelo}

Estruturas auxiliares:  

  \vspace{-1cm}   \hspace{1cm}   \itemtrig\ Posição em $A$, posição em $B$, vetores com 
  $\displaystyle \frac{n}{2}$ posições.
  
  Posição em $A[i]$ diz em que posição o elemento $B[i]$
 deveria ficar, caso fosse inserido em $A$, de maneira a manter a ordenação.
 
 Posição em $B[i]$ é análogo.
 
 \end{slide}
  
  
\begin{slide}
  \stitle{Ordenação: Algoritmo Mergesort paralelo}
\textbf{\blue Algoritmo Merge}
\vspace{-1cm} \begin{codebox}
  \zi \For $0 \leq i \leq  \frac{n}{2}$ \DoPar 
  \zi $posicaoEmA[i] := buscaBinaria(B[i], A, 0,  \frac{n}{2} - 1)$
  \zi $posicaoEmB[i] := buscaBinaria(A[i], B, 0,  \frac{n}{2} - 1)$
  \zi $C[posicaoEmA[i] + i] := B[i]$
  \zi $C[posicaoEmB[i] + i] := A[i]$
  \zi \End   
\end{codebox}
\end{slide}
\begin{slide}

\textbf{\blue Algoritmo Busca Binária ($num, vetor, i, f$)}
\vspace{-1cm} \begin{codebox}
  \zi $inicio := i$, $fim := f$
  \zi \While $inicio < fim$ \DoSeq 
  \zi $meio := [(inicio + fim)/2]$
  \zi \If $num < vetor[meio]$ \Then
  \zi $fim := meio - 1$
  \zi \ElseIf $num > vetor[meio]$ \Then  
  \zi $inicio := meio + 1$
  \zi \End   
  \zi \End   
  \zi \If $num < vetor[meio]$ \Then
  \zi \Return $meio$
  \zi \ElseIf $num > vetor[meio]$ \Then  
  \zi \Return $meio+1$
  \zi \End   
\end{codebox}
 \end{slide}

\begin{slide}
Ex.: $n = 8$
   
\begin{center}
\includegraphics[height=8.3cm]{fig01}
\end{center} 
\end{slide}  
  
\begin{slide}
  \stitle{Ordenação: Algoritmo Mergesort paralelo}
  
 Submodelo e complexidades:
 
 Submodelo: CREW
 
 Complexidades
 
  \vspace{-1cm}   \hspace{1cm} \itemtrig\ Tempo: $O(\log n)$
  
  \vspace{-1cm}   \hspace{1cm} \itemtrig\ Processador: $O(n)$
 \end{slide}
  
  
\begin{slide}
  \stitle{Caso A e B tenham elementos iguais}
	Usamos 2 rotinas de busca binária. 
	
	\vspace{-1cm}   \hspace{1cm} \itemtrig\ Busca binária 1 retorna a posição em que $B[i]$ seria inserido em A, de maneira que ele seja inserido após os elementos de A iguais a ele. 
	
	\vspace{-1cm}   \hspace{1cm} \itemtrig\ Busca binária 2 retorna a posição em que $A[i]$ seria inserido em B, de maneira que ele seja inserido antes do elemento de B iguais a ele.
 \end{slide}
  
  
\begin{slide}
  \stitle{Ordenação: Algoritmo Mergesort paralelo}
O algoritmo de ordenação utiliza o algoritmo de merge com uma subrotina da forma:


\textbf{\blue Merge($A, iniA, B, iniB, C, iniC, tamC$)}
 \end{slide}

  
  
\begin{slide}
  \stitle{Ordenação: Algoritmo Mergesort paralelo}
\textbf{\blue Merge($A, iniA, B, iniB, C, iniC, tamC$)}

	\vspace{-1cm} \begin{codebox}
  \zi \For $0 \leq i \leq \frac{tamC}{2} - 1$ \DoPar
  \zi $posicaoEmA[iniB + i] := buscaBinaria(B[iniB + i], A,$
	\zi \hspace{14cm} $ iniA, iniA + \frac{tamC}{2} - 1)$
  \zi $posicaoEmB[iniA + i] := buscaBinaria(A[iniA + i], B,$
	\zi \hspace{14cm} $ iniB, iniB + \frac{tamC}{2} - 1)$
  \zi $C[posicaoEmA[iniB + i] + iniB + i] := B[iniB + i]$ 
  \zi $C[posicaoEmB[iniA + i] + iniA + i] := A[iniA + i]$ 
  \zi \End   
\end{codebox}
 \end{slide}
  

  
\begin{slide}
  \stitle{Ordenação: Algoritmo Mergesort paralelo}
	Entrada:  

  \vspace{-1cm}   \hspace{1cm}   \itemtrig\ $S$: vetor de $n$ elementos a ser ordenado

  \vspace{-1cm}   \hspace{1cm}   \itemtrig\ $n$: potência de 2
	
  Saída:
		
  \vspace{-1cm}   \hspace{1cm}   \itemtrig\ $R$: vetor de $n$ elementos com os elementos de S ordenado
	
	Estrutura auxiliar:
	
	\vspace{-1cm}   \hspace{1cm}   \itemtrig\ $T$: vetor de $n$ posições. Usado para fazer a cópia de R.
 \end{slide}
  
  
\begin{slide}
  \textbf{\blue Algoritmo Mergesort}		

	\vspace{-1cm} \begin{codebox}
  \zi \For $0 \leq i \leq n - 1$ \DoPar
	\zi $R[i] := S[i]$
	\zi \End
	\zi \Comment Loop sequencial, subindo na árvore
	\zi \For $j := (\log n) - 1$ \To 0 \DoSeq
	\zi \For $0 \leq i \leq n-1$ \DoPar
	\zi $T[i] := R[i]$
  \zi \End   
  \zi $tam := n/2^j$ \Comment Tamanho da sequência ordenada 
	\zi \hspace{4.2cm}  \Comment a ser obtida neste nível
	\zi \For $0 \leq i \leq 2^j-1$ \DoPar
	\zi $Merge(T, i * tam, T, i * tam + \frac{tam}{2}, R, i * tam, tam)$
  \zi \End   
  \zi \End   
\end{codebox}
	
\end{slide}

\begin{slide}
Ex.: $n = 8$
   
\begin{center}
\includegraphics[height=12.3cm]{fig02}
\end{center} 
\end{slide}  
  
  
\begin{slide}
  \stitle{Ordenação: Algoritmo Mergesort paralelo}
  Submodelo: CREW (leitura concorrente em T e tam)
  
  Complexidades:

  \vspace{-1cm}   \hspace{1cm}  \itemtrig\ Tempo: $O(\log^2 n)$ ($\log n$ passos do sort e $\log n$ passos do merge)

  \vspace{-1cm}   \hspace{1cm}  \itemtrig\ Processadores: $O(n)$
\end{slide}


\begin{slide}
  \stitle{Ordenação: Algoritmo Mergesort paralelo}
  
  No nível $j$ da árvore, usamos 
  
    \vspace{-1cm}   \hspace{1cm}  \itemtrig\ $2^j$ processadores, cada um fazendo um merge.
    
    \vspace{-1cm}   \hspace{1cm}  \itemtrig\ Para cada merge, cada processador usa $\frac{tam}{2}$ processadores.
    
    \vspace{-1cm}   \hspace{1cm}  \itemtrig\ Logo, no nível $j$ usamos $2^j \cdot \frac{tam}{2}$ processadores
    
  $$ 2^j \cdot \frac{tam}{2} = 2^j \cdot \frac{\frac{n}{2^j}}{2} = \frac{n}{2}$$  
\end{slide}


\begin{slide}
  \stitle{O problema da envoltória convexa}
\end{slide}

\begin{slide}
  \stitle{O problema da envoltória convexa}
  Dado um conjunto $S = \{p_1, p_2, \cdots, p_n\}$ de $n$ pontos no plano, cada um representado pelas suas coordenadas $(x,y)$, a \textbf{envoltória convexa planar} de S é o menor polígono convexo contendo todos os $n$ pontos de $S$.
\end{slide}

\begin{slide}
  \stitle{O problema da envoltória convexa}
O problema da envoltória convexa é o de determinar a lista ordenada (sentido horário) $CH(S)$ de pontos de  $S$ definindo a fronteira da envoltória convexa de $S$. 
\end{slide}

\begin{slide}
  \stitle{O problema da envoltória convexa}

Considere o conjunto $S$ de pontos abaixo. O Fecho convexo de $S$ é dado por $CH(S) = \{v_1,v_2,v_3,v_4,v_5,v_6,v_7,v_8\}$
   
\begin{center}
\includegraphics[height=8.3cm]{fig03}
\end{center} 
\end{slide}

\begin{slide}
  \stitle{Algoritmo paralelo para o problema da envoltória convexa}
\end{slide}  

\begin{slide}
  \stitle{Algoritmo paralelo para o problema da envoltória convexa}
  
  Sejam $p$ e $q$ pontos de $S$ com a menor e a maior coordenada $x$, respectivamente. Claramente $p$ e $q$ pertencem a $CH(S)$ e particionam $CH(S)$ em uma envoltória superior $UH(S)$ consistindo de todos os pontos de $p$ e $q$ de $CH(S)$ (sentido horário) e uma envoltória inferior $LH(S)$ definida de modo análogo de $p$ a $q$.
\end{slide}  

\begin{slide}
  \stitle{Algoritmo paralelo para o problema da envoltória convexa}
Considere o conjunto $S$ de pontos abaixo. 
   
\begin{center}
\includegraphics[height=7.3cm]{fig03}
\end{center} 

	\vspace{-1cm}   \hspace{1cm}   \itemtrig\  $UH(S) = \{v_1,v_2,v_3,v_4,v_5\}$

	\vspace{-1cm}   \hspace{1cm}   \itemtrig\  $LH(S) = \{v_5,v_6,v_7,v_8,v_1\}$
\end{slide}  

\begin{slide}
  \stitle{Algoritmo paralelo para o problema da envoltória convexa}
\itemtrig\  Vamos mostrar como computar $UH(S)$. A computação de $LH(S)$ é feita de modo análogo.

	\vspace{-1cm}   \itemtrig\  A ordenação pode ser feito em uma EREW PRAM em tempo  $O(\log n)$ com $n$ processadores
	
	\vspace{-1cm}   \itemtrig\  Assumimos por simplicidade que dados dois pontos quaisquer de $S$	, eles não possuem a mesma coordenada $x$ ou $y$ e que $n$ é potência de 2.
\end{slide}


\begin{slide}
  \stitle{Algoritmo paralelo para o problema da envoltória convexa}
  Iniciamos com a ordenação dos pontos $p_i$ pelas suas coordenadas $x$.
  
  Seja $x(p_1) < x(p_2) < \cdots < x(p_n)$, onde $x(p_i)$ é a coordenada $x$ de $p_i$
\end{slide}


\begin{slide}
  \stitle{Algoritmo paralelo para o problema da envoltória convexa}
Seja $S_1 = (p_1, p_2, \cdots, p_{\frac{n}{2}})$ e $S_2 = (p_{\frac{n}{2} + 1}, p_{\frac{n}{2} + 2}, \cdots, p_{n})$.

Vamos supor que $UH(S_1)$ e $UH(S_2)$ é a tangente comum tal que $UH(S_1)$ e $UH(S_2)$ estão abaixo dela.
\end{slide}
\begin{slide}
  \stitle{Algoritmo paralelo para o problema da envoltória convexa}
\begin{center}
\includegraphics[height=8.3cm]{fig04}
\end{center} 

O segmento de linha $(a,b)$ é a tangente comum superior  da envoltória de $S_1$ e $S_2$
\end{slide}


\begin{slide}
  \stitle{Algoritmo paralelo para o problema da envoltória convexa}
  A computação da tangente comum superior entre $UH(S_1)$ e $UH(S_2)$ pode ser feita em tempo sequencial $O(\log n)$, usando o método de busca binária. Isso pode ser feito de forma mais eficiente.
\end{slide}


\begin{slide}
  \stitle{Algoritmo paralelo para o problema da envoltória convexa}
Sejam $UH(S_1)=(q_1, \cdots, q_s)$ e $UH(S_2) = (q_1', \cdots, q_t')$ as envoltórias superiores de $S_1$ e $S_2$, respectivamente, dados na ordem da esquerda para a direita. Observe que a tangente comum superior tenha sido deteminada e seja dado por $(q_i, q_j')$. 
\end{slide}


\begin{slide}
  \stitle{Algoritmo paralelo para o problema da envoltória convexa}
Então, $UH(S)$ é o vetor consistindo das primeiras $i$ entradas de $UH(S_1)$ e as últimas $t-j+1$ entradas de $UH(S_2)$; isto é, $UH(S) = (q_1, \cdots, q_i, q_j', \cdots, q_t')$. Se $s$ e $t$ são dados, uma vez que $i$ e $j$ são conhecidos, $UH(S)$ e seu tamanho pode ser determinado em tempo paralelo $O(1)$ com $n$ processadores.
\end{slide}


\begin{slide}
  \stitle{Algoritmo paralelo para o problema da envoltória convexa}
  Entrada:
  
   \vspace{-1cm}   \hspace{1cm}  \itemtrig\ Um conjunto $S$ de $n$ pontos no plano, dos quais não existam dois pontos que tenham as mesmas coordenadas $x$ ou $y$, tal que $x(p_1) <x(p_1) < \cdots <x(p_n)$, onde $n$ é uma potência de 2.
   
 Saída:
 
    \vspace{-1cm}   \hspace{1cm}  \itemtrig\ Envoltória convexa superior de $S$
\end{slide}


\begin{slide}
  \stitle{Algoritmo paralelo para o problema da envoltória convexa}

\textbf{\blue Algoritmo Envoltória superior simples}
\vspace{-1cm} \begin{codebox}
  \li Se $n \leq 4$, então use um método de força bruta 
  \zi para determinar $UH(S)$ e finalize
  \li Sejam $S_1 = (p_1, p_2, \cdots, p_{\frac{n}{2}})$ e $S_2 = (p_{\frac{n}{2} + 1}, p_{\frac{n}{2} + 2}, \cdots, p_{n})$. 
  \zi Recursivamente, compute $UH(S_1)$ e $UH(S_2)$ em paralelo.
  \li Encontre a tangente comum superior entre $UH(S_1)$ e $UH(S_2)$ 
  \zi e deduza a envoltória convexa superior de S. 
\end{codebox}  
\end{slide}


\begin{slide}
  \stitle{Algoritmo paralelo para o problema da envoltória convexa}
Submodelo CREW

    \vspace{-1cm}   \hspace{1cm}  \itemtrig\ Tempo: $O(\log^2 n)$ 
    
    \vspace{-1cm}   \hspace{1cm}  \itemtrig\ Processadores: $O(n \log n)$ 

\end{slide}


\begin{slide}
  \stitle{Fim}
\end{slide}
\end{document}